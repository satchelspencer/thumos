## problem set 3
satchel spencer

1. 
   1. 0xa is 1010 and corresponds to the polynomial x^3 + x
   2. a+7 = x^3 + x + x^2 + x + 1 = x^3 + x^2 + 1 = 13
   3. a*7 = (x^3 + x)(x^2 + x + 1) 
     = x^5 + x^4 + x^3 + x^3 + x^2 + x % x^4 + x^3 + 1
       x^5 + x^4 + x^2 + x / x^4 + x^3 + 1 = x
     + x^5 + x^4 +       x
                   x^2
     x^2 = x^2+0x+0 = 100 = 4
2. the result of each cell in mix column can be seen as a polynomial operation:
   - adding two constant cells results in another constant cell
   - adding a constant cell and an active cell will yeild another active cell since each value in the active cell will be changed by the same amount.
   - the result cells of mix column are found from coefficient rotations of the polynomial 2x^3+3x2+x+1. In the case of one active cell and all others constant, each resultant cell in the column will be the addition of 3 constant cells and one active. The 3 constants added together remain constant. When added to the on active cell, the result is always active. So, mix column always results in all active cells in this case.
3. Rijndael Attack:
~~~ C
#include "rijndael-alg-fst.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define AES_ROUNDS 4
#define AES_KEY_BITLEN  128

unsigned rek[1024];   /* main AES encryption key  */

/* inverted s-box */
unsigned char inv_s[256] = 
 {
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
 };
 
 /* s-box */
 unsigned char s[256] = 
 {
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
 };
 
 /* rcon */
 unsigned char rcon[256] = {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c};

unsigned char pkbs[16][16];
unsigned char pkbCount[16];

/* read string of 32 chars as hex into unsigned char [16] */
void read_hex_string(char * buf, unsigned char * out, int len){
	int i;
	int j;
	char *p;
	char * in[1];
	unsigned char byte;
	for(i=0;i<len;i+=2){
		in[0] = buf[i+1];
		byte = strtol(in, p, 16);
		in[0] = buf[i];
		byte += strtol(in, p, 16)*16;
		out[i/2] = byte;
	}
}

/* given round key, find master key */
void reverse_key(unsigned char * key, unsigned char * out, int round){
	int i;
	int j;
	unsigned char prev[16]; //previous round key (to be determined)
	unsigned char temp[4];
	unsigned char t;
	for(i=12;i>=0;i-=4){ //loop through all 4 byte chunks backwards
		if(i == 0){ //first chunk (special)
			for(j=12;j<16;j++) temp[j%4] = prev[j];
			/* rotate left one byte */
			t = temp[0];
			for(j=0;j<3;j++) temp[j] = temp[j+1];
			temp[3] = t;
			/* run each through s-box */
			for(j=0;j<4;j++){
				temp[j] = s[temp[j]];
				if(j == 0) temp[j] ^= rcon[round]; //xor by rcon of round on first byte
			}
		}else{ //otherwise tmp is just the 4 bits before it
			for(j=i;j<i+4;j++) temp[j%4] = key[j-4];
		}
		for(j=i;j<i+4;j++){
			prev[j] = temp[j%4]^key[j]; //set the previous (16 bytes 'behind' key)
		}
	}
	if(round > 1) reverse_key(prev, out, round-1); //continue until master key
	else{
		for(j=0;j<16;j++) out[j] = prev[j]; //copy to output
	}
}

void permute(int i, unsigned char * key);

int main(){
	FILE *cypherTexts;
	cypherTexts = fopen("cyphertexts", "r");
	char line[33]; 
	unsigned char ct[16]; //cyphertext byte array
	int i;
	int j;
	int k;
	unsigned char accu[16][255]; //balance accumulator
	unsigned char pkb; //possible key byte
	/* zero accumulator out */
	for(i=0;i<16;i++){
		for(pkb=0;pkb<255;pkb++){
			accu[i][pkb] = 0;
		}
	}
	/* read each cyphertext */
	while(fgets(line, sizeof line, cypherTexts)){
        if(strlen(line) == 32){
			read_hex_string(line, ct, 32); //parse line into char array			
			for(i=0;i<16;i++){
				for(pkb=0;pkb<255;pkb++){
					accu[i][pkb] ^= inv_s[ct[i]^pkb]; //xor possible value into accumulator
				}
			}
		}
    }
	/* set up possible key accumulators */
    for(i=0;i<16;i++){
		pkbCount[i] = 0;
	}
	/* check for balance */
    for(i=0;i<16;i++){
		for(pkb=0;pkb<255;pkb++){
			if(accu[i][pkb] == 0) pkbs[i][pkbCount[i]++] = pkb; //add it to our list of possible keybits
		}
	}
	/* permute all possible keys from given keybit options */
	unsigned char pk[16];
	permute(0, pk);
	return;
}

void permute(int i, unsigned char * key){
	/* i is byte being permuted */
	int j;
	int k;
	for(j=0;j<pkbCount[i];j++){ //loop over all possible bytes at this index
		unsigned char pkey[16];
		for(k=0;k<i;k++) pkey[k] = key[k]; //copy over what we have so far
		pkey[i] = pkbs[i][j]; //concat in possible byte
		if(i < 15) permute(i+1, pkey); //go deeper for each possible byte
		else{
			/* we have a full potential round key now */
			unsigned char master[16];
			reverse_key(pkey, master, 4); //reverse it to master key
			rijndaelKeySetupEnc(rek, (unsigned char *)master, 128);
			/* test with a known pt/ct pair */
			unsigned char pt[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
			unsigned char oct[16] = {0x89, 0xa2, 0x34, 0x22, 0x4c, 0xc5, 0xef, 0x30, 0xd3, 0x39, 0xc6, 0x7a, 0xcd, 0xbf, 0xff, 0x9d};
			unsigned char ct[16];
			rijndaelEncrypt(rek, AES_ROUNDS, pt, ct);
			/* compare byte by byte and reject as needed */
			char good = 1;
			for(k=0;k<16;k++){
				if(ct[k] != oct[k]){
					good = 0;
					break;
				}
			}
			if(good){
				/* we got it! */
				printf("got key: ");
				for(k=0;k<16;k++) printf("%02x", master[k]);
				printf("\n");
			}
		}
	}
}
   ~~~
   Program Output  
   ~~~
   got key: 1b84227a90fe6607c3a9aa1781b7180f
   ~~~
